
RxJS vs NgRX
RxJS is an async event handling library. And thats it. It builds upon the idea of the observable pattern and gives a few slightly higher level abstractions on top of that (like Subjects) for more fine grained event handling. Look into JavaScript Promises. It's a similar idea. A Promise to an Observable is like a single value to an array. A Promise resolves (once) and an Observable can emit multiple times. With a promise you can add a callback to be called eith the result of the Promise while with an observable you can subscribe to the events it emits.
And RxJS provides a bunch of operators to handle these. Thats all the library does and it does it pretty damn good.
NgRX is a whole different can of worms, solving a different problem. It implements the Redux State management pattern in Angular and is heavily using RxJS. (Just like Angular uses RxJS).



Without State Management:
◇ In traditional setups, the lifecycle of data (often represented as observables) is tied to the lifecycle of the component.

◇ When navigating away from a component and returning, the component is destroyed and recreated. This means we often need to make new HTTP requests to fetch data again, which is inefficient.

Problems:
▪ Constant HTTP requests when switching between screens.
▪ Redundant data fetching impacts performance and user experience.

What We Want:
▪ An in-memory database on the client side that holds data while the app is active.
▪ Immediate reflection of data modifications.
▪ Enhanced performance and smoother user experience.

Solution: We need a state management tool like NgRx to avoid these issues.

What is NgRx Store?
• The store is like an in-memory database that holds data shared across multiple components of the application.
• Components do not directly modify the state (the data stored in the store). Instead, they dispatch an action, which is a simple JavaScript object containing a type (describing what should be done) and an optional payload (the data needed to perform the action).
• The store, based on the action's type, will call a reducer function. A reducer is a plain JavaScript function that computes a new version of the state based on the current state and the dispatched action’s payload.


NgRx Store Architecture:
NgRx uses the store architecture to manage the state. Here's how it works:

Dispatching Actions to the Store:
To modify the store’s state, we use this.store.dispatch(ACTION).

Action:
◇ A plain JavaScript object sent to the store to trigger a modification of the state.
◇ Every action has a type (describing what happened) and usually a payload (data needed for the action).
◇ Actions are events reporting that something has happened at the component level.
◇ Actions inform the store about an occurrence, but they are the only way to modify the state of the store.

Example:
	this.auth.login(userDetails)
  .pipe(
    tap(user => {
      this.store.dispatch({
        type: 'Login Action',
        payload: { user }
      });
    })
  ).subscribe();


However, it's better to follow the convention by creating action files that define type-safe actions:

Example:
export const login = createAction(
  '[Login Page] User Login',
  props<{ user: User }>()
);

const newLoginAction = login({ user });



Note: Dispatching an action does not modify the store state directly. The store needs to know how to handle the action through reducers.

Reducer:
 Documentation : Reducers in NgRx are responsible for handling transitions from one state to the next state in your application. Reducer functions handle these transitions by determining which actions to handle based on the action's type.
• A reducer defines what the store should do in response to an action.
• Reducers are functions that the store uses to calculate the new state based on the previous state and the action's payload.

Important:
◇ Reducers do not modify the state directly. Instead, they return a new version of the state.

  1- create Actions loginAction
  2- create a State* interface AppState
  3- create the initialState of type State* initialState
  4- create the reducer function
  
  export const scoreBoardReducer(
  	initialState,
	  on(login, state => {
		  ...state,
	 	 loggedIn:true
		}
	)
  ); 
  
  After modyfing the state of the store now how to access the data !! 
  one way is :
  
  constructor(private store:Store<AppStore>){}
  
  ngOnInit(){
  this.isLoggedIn$ = this.store
  	.pipe(
		map(state=> !!state['auth'].user) // negating two time to converting to a boolean  	
	  );
  }
  you can query the store like this but there is a better way!
