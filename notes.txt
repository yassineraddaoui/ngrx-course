
RxJS vs NgRX
RxJS is an async event handling library. And thats it. It builds upon the idea of the observable pattern and gives a few slightly higher level abstractions on top of that (like Subjects) for more fine grained event handling. Look into JavaScript Promises. It's a similar idea. A Promise to an Observable is like a single value to an array. A Promise resolves (once) and an Observable can emit multiple times. With a promise you can add a callback to be called eith the result of the Promise while with an observable you can subscribe to the events it emits.
And RxJS provides a bunch of operators to handle these. Thats all the library does and it does it pretty damn good.
NgRX is a whole different can of worms, solving a different problem. It implements the Redux State management pattern in Angular and is heavily using RxJS. (Just like Angular uses RxJS).



Without State Management:
◇ In traditional setups, the lifecycle of data (often represented as observables) is tied to the lifecycle of the component.

◇ When navigating away from a component and returning, the component is destroyed and recreated. This means we often need to make new HTTP requests to fetch data again, which is inefficient.

Problems:
▪ Constant HTTP requests when switching between screens.
▪ Redundant data fetching impacts performance and user experience.

What We Want:
▪ An in-memory database on the client side that holds data while the app is active.
▪ Immediate reflection of data modifications.
▪ Enhanced performance and smoother user experience.

Solution: We need a state management tool like NgRx to avoid these issues.

What is NgRx Store?
• The store is like an in-memory database that holds data shared across multiple components of the application.
• Components do not directly modify the state (the data stored in the store). Instead, they dispatch an action, which is a simple JavaScript object containing a type (describing what should be done) and an optional payload (the data needed to perform the action).
• The store, based on the action's type, will call a reducer function. A reducer is a plain JavaScript function that computes a new version of the state based on the current state and the dispatched action’s payload.


NgRx Store Architecture:
NgRx uses the store architecture to manage the state. Here's how it works:

Dispatching Actions to the Store:
To modify the store’s state, we use this.store.dispatch(ACTION).

Action:
◇ A plain JavaScript object sent to the store to trigger a modification of the state.
◇ Every action has a type (describing what happened) and usually a payload (data needed for the action).
◇ Actions are events reporting that something has happened at the component level.
◇ Actions inform the store about an occurrence, but they are the only way to modify the state of the store.

Example:
	this.auth.login(userDetails)
  .pipe(
    tap(user => {
      this.store.dispatch({
        type: 'Login Action',
        payload: { user }
      });
    })
  ).subscribe();


However, it's better to follow the convention by creating action files that define type-safe actions:

Example:
export const login = createAction(
  '[Login Page] User Login',
  props<{ user: User }>()
);

const newLoginAction = login({ user });



Note: Dispatching an action does not modify the store state directly. The store needs to know how to handle the action through reducers.

Reducer:
 Documentation : Reducers in NgRx are responsible for handling transitions from one state to the next state in your application. Reducer functions handle these transitions by determining which actions to handle based on the action's type.
• A reducer defines what the store should do in response to an action.
• Reducers are functions that the store uses to calculate the new state based on the previous state and the action's payload.

Important:
◇ Reducers do not modify the state directly. Instead, they return a new version of the state.

  1- create Actions loginAction
  2- create a State* interface AppState
  3- create the initialState of type State* initialState
  4- create the reducer function
  
  export const scoreBoardReducer(
  	initialState,
	  on(login, state => {
		  ...state,
	 	 loggedIn:true
		}
	)
  ); 
  
  After modyfing the state of the store now how to access the data !! 
  one way is :
  
  constructor(private store:Store<AppStore>){}
  
  ngOnInit(){
  this.isLoggedIn$ = this.store
  	.pipe(
		map(state=> !!state['auth'].user) // negating two time to converting to a boolean  	
	  );
  }
  you can query the store like this but there is a better way!


Selectors:
  
	documentation : 
		Selectors are pure functions used for obtaining slices of store state.

  
  export const isLoggedIn = createSelector(
  	state=>state["auth"],
  	(auth)=> !!auth.user
  );
  
  so when we want to get the value :
	
  
  as long as the input(state object) doesnt change the output is not going to be recalculated !
	//mapping function with a memory !!   
 ngOnInit(){
 	this.isLoggedIn$= this.store
 		.pipe(
			select(isLoggedIn) 		
		 );
 }

	Select (distinctUntilChanged)vs map
	Selectors are memoized, which means that they're only invoked when the state changes


Effects:
Documentation:

In a service-based Angular application, components typically interact directly with external resources through services. However, NgRx effects provide a way to handle those interactions while keeping components isolated from these tasks. Effects allow us to manage asynchronous operations, such as fetching data, long-running tasks that produce multiple events, and other external interactions, without the components needing explicit knowledge of them.

Example Without NgRx Effects:

constructor(actions$: Actions) {
    actions$.subscribe(action => {
        // Wait for a login action to get emitted
        if (action.type === '[Login Page] User Login') {
            // Side Effect: Store user data in localStorage
            localStorage.setItem('user', JSON.stringify(action['user']));
        }
    });
}
Side Effect: This is something additional we want to perform after an action has been dispatched and processed by the store (e.g., storing data in localStorage).
Issues:
Not type-safe.
Lacks exception handling.
NgRx Solution:
Using NgRx, we can manage side effects in a more organized way, leveraging the createEffect function to define them declaratively and with type safety.

Example with NgRx Effects:

constructor(private actions$: Actions) {}

login$ = createEffect(() => 
    this.actions$.pipe(
        ofType(AuthActions.login), // Listen for the login action
        tap(action => localStorage.setItem('user', JSON.stringify(action.user))) // Side effect: store user data
    ),
    { dispatch: false } // This effect does not result in another action
);
OfType: Filters the actions to only respond to the specified action type (in this case, the login action).
Tap: Executes side effects without modifying the stream.
dispatch: false: This indicates that the effect does not dispatch a new action as a result.
By using NgRx effects, we can handle side effects in a type-safe, maintainable, and organized way, separating concerns between the component and the external interactions.


In NgRx, runtime checks are configuration options that enhance the robustness and correctness of your application's state management. Here’s an explanation of each runtime check:

1. strictStateImmutability
Purpose: Ensures that the state in your store is immutable.
Description: When this check is enabled, NgRx will verify that the state object is not mutated directly. This is crucial because mutating the state can lead to unexpected behavior in your application and can cause issues with change detection.
Usage: It helps developers follow best practices by ensuring that they always create new state objects rather than modifying existing ones.
2. strictActionImmutability
Purpose: Ensures that action objects remain immutable.
Description: This check validates that action objects (the payload of actions dispatched to the store) are not mutated after they are dispatched. Like state immutability, action immutability is important for maintaining predictable state transitions.
Usage: It prevents side effects that could occur if actions were modified after dispatching, helping to ensure that all parts of the application see a consistent action state.
3. strictActionSerializability
Purpose: Ensures that actions dispatched to the store are serializable.
Description: This check confirms that all properties of action objects can be serialized, which is particularly useful for debugging and logging. Non-serializable objects can lead to issues when persisting state or debugging applications.
Usage: By enforcing serializability, developers can avoid bugs related to state restoration, time travel debugging, and ensure that the application behaves consistently across different environments.
4. strictStateSerializability
Purpose: Ensures that the state stored in the NgRx store is serializable.
Description: This check verifies that the entire state tree is composed of serializable objects. If the state contains non-serializable values, such as functions or complex objects, it may cause issues when trying to persist or reproduce the application state.
Usage: Ensuring state serializability helps maintain consistent behavior during debugging and testing and allows for effective state transfer between different environments (e.g., server-side rendering).



